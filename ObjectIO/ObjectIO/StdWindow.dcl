definition module StdWindow


//	********************************************************************************
//	Clean Standard Object I/O library, version 1.2
//	
//	StdWindow defines functions on windows and dialogues.
//	********************************************************************************


from	StdFunc			import St
import	StdMaybe, StdWindowDef
from	StdPSt			import PSt, IOSt
from	StdControlClass	import Controls, ControlState


//	Functions applied to non-existent windows or unknown ids have no effect.
class Windows wdef where
	openWindow		:: .ls !(wdef .ls (PSt .l .p)) !(PSt .l .p)
								   -> (!ErrorReport,!PSt .l .p)
	getWindowType	::      (wdef .ls .pst)	-> WindowType

class Dialogs wdef where
	openDialog		:: .ls !(wdef .ls (PSt .l .p)) !(PSt .l .p)
					->  (  !ErrorReport,            !PSt .l .p)
	openModalDialog	:: .ls !(wdef .ls (PSt .l .p)) !(PSt .l .p)
					->  (!(!ErrorReport,!Maybe .ls),!PSt .l .p)
	getDialogType	::      (wdef .ls .pst)	-> WindowType

/*	open(Window/Dialog) opens the given window(dialog).
	If the Window(Dialog) has no WindowIndex attribute (see StdWindowDef), then the 
	new window is opened frontmost. 
	If the Window(Dialog) has a WindowIndex attribute, then the new window is 
	opened behind the window indicated by the integer index:
		Index value 1 indicates the top-most window. 
		Index value M indicates the bottom-most modal window, if there are M modal 
			windows. 
		Index value N indicates the bottom-most window, if there are N windows. 
		If index<M, then the new window is added behind the bottom-most modal window
			(at index M). 
		If index>N, then the new window is added behind the bottom-most window
			(at index N). 
	openModalDialog always opens a window at the front-most position. 
	openWindow may not be permitted to open a window depending on its 
		DocumentInterface (see the comments at the ShareProcesses instances in 
		module StdProcess).
	In case the window does not have an Id, it will obtain a fresh Id. The Id can 
	be reused after closing this window. 
	In case a window with the same Id is already open the window will not be opened. 
	In case controls are opened with duplicate Ids, the window will not be opened.
	openModalDialog terminates when:
		the modal dialog has been closed (by means of closeWindow), or the process 
		has been terminated (by means of closeProcess). If the ErrorReport==NoError,
		then also the final local state of the modal dialog is returned, otherwise
		Nothing.
*/

instance Windows (Window c)	| Controls c
instance Dialogs (Dialog c) | Controls c


closeWindow			:: !Id !(PSt .l .p) -> PSt .l .p
closeActiveWindow	::     !(PSt .l .p) -> PSt .l .p
/*	If the indicated window is not an inactive modal dialog, then closeWindow closes 
		the window/dialogue.
		In case the Id of the window was generated by open(Window/Dialog), it will 
		become reusable for new windows/dialogues.
		No window is closed in case of an unknown Id.
	closeActiveWindow closes the currently active window/dialogue (see also
		getActiveWindow) if such a window could be found.
*/

closeControls :: !Id [Id] !Bool	!(IOSt .l .p) -> IOSt .l .p
/*	closeControls removes the indicated controls (second argument) from the 
	indicated window (first argument) and recalculates the layout iff the Boolean 
	argument is True.
*/

closeAllControls :: !Id !(IOSt .l .p) -> IOSt .l .p
/*	closeAllControls removes all controls from the indicated window.
*/

closePopUpControlItems	:: !Id ![Index] !(IOSt .l .p) -> IOSt .l .p
/*	closePopUpControlItems closes PopUpControlItems by their Index position of the 
	indicated PopUpControl. 
	If the currently checked element of a PopUpControl is closed, the first 
	remaining element of that PopUpControl will be checked. 
*/


openControls			:: !Id .ls (cdef .ls (PSt .l .p)) !(PSt .l .p)
										  -> (!ErrorReport,!PSt .l .p)
											  |  Controls cdef
openCompoundControls	:: !Id .ls (cdef .ls (PSt .l .p)) !(PSt .l .p)
										  -> (!ErrorReport,!PSt .l .p)
											  |  Controls cdef
openPopUpControlItems	:: !Id !Index ![PopUpControlItem (PSt .l .p)]
										!(IOSt .l .p) -> IOSt .l .p
/*	openControls
		adds the given controls argument to the indicated window or dialog. 
	openCompoundControls
		adds the given controls argument to the indicated compound control.
	openPopUpControlItems
		adds the PopUpControlItems to the indicated PopUpControl behind the item at
		the given index position (counted from 1). 
	The window/dialog is not resized.
	These functions have no effect in case the indicated window/dialog/compound 
	control could not be found (ErrorUnknownObject) or if controls are opened with 
	duplicate Ids (ErrorIdsInUse).
*/


setControlPos :: !Id ![(Id,ItemPos)]	!(IOSt .l .p) -> (!Bool,!IOSt .l .p)
/*	setControlPos changes the current layout position of the indicated controls to 
	their new positions. 
	If there are relatively laynout controls, then their layout also changes. The 
	window is not resized.
	The Boolean result is False iff the window is unknown. 
*/


controlSize		:: !(cdef .ls (PSt .l .p)) !Bool
				   !(Maybe (Int,Int)) !(Maybe (Int,Int)) !(Maybe (Int,Int))
				   !(PSt .l .p)
				-> (!Size,!PSt .l .p) | Controls cdef
/*	controlSize calculates the size of the given control definition as it would be 
		opened as an element of a window/dialog.
	The Boolean argument determines whether a window (True) or a dialog (False) is
		intended.
	The Maybe arguments are the prefered horizontal margins, vertical margins, and 
		item spaces (see also the (Window/Control)(H/V)Margin and 
		(Window/Control)ItemSpace attributes). If Nothing is specified, their 
		default values with respect to the window/dialog are used.
*/


setActiveWindow	:: !Id		!( PSt .l .p) -> PSt .l .p
getActiveWindow	::			!(IOSt .l .p) -> (!Maybe Id,!IOSt .l .p)
/*	setActiveWindow makes the indicated window the active window. 
		If there are modal dialogues, then the window will be placed behind the last
		modal dialog.
		setActiveWindow has no effect in case the window is unknown or is a modal 
		dialog.
	getActiveWindow returns the Id of the window that currently has the input focus
		of the interactive process. 
		Nothing is returned if there is no such window.
*/

setActiveControl:: !Id		!( PSt .l .p) -> PSt .l .p
getActiveControl::			!(IOSt .l .p) -> (!(!Bool,!Maybe Id),!IOSt .l .p)
/*	setActiveControl makes the indicated (PopUp/Edit/Custom/Compound)Control the active
		control. This succeeds only if its parent window is already active.
	getActiveControl returns the Id of the (PopUp/Edit/Custom/Compound)Control that 
		currently has the input focus.
		The Boolean result is True only iff such a control could be found.
		Nothing is returned if the control has no Id attribute or if the Boolean result
		is False. 
*/


stackWindow		:: !Id !Id	!(IOSt .l .p) -> IOSt .l .p
/*	stackWindow id1 id2 places the window with id1 behind the window with id2. 
	If id1 or id2 is unknown, or id1 indicates a modal window, stackWindow does 
	nothing.
	If id2 indicates a modal window, then the window with id1 is placed behind the 
	last modal window. 
*/

getWindowStack	:: !(IOSt .l .p) -> (![(Id,WindowType)],!IOSt .l .p)
getWindowsStack	:: !(IOSt .l .p) -> (![Id],				!IOSt .l .p)
getDialogsStack	:: !(IOSt .l .p) -> (![Id],				!IOSt .l .p)
/*	getWindowStack returns the Ids and WindowTypes of all currently open windows, 
	in the current stacking order starting with the active window.
	get(Windows/Dialogs)Stack is equal to getWindowStack, restricted to Windows 
	instances and Dialogs instances respectively.
*/


getDefaultHMargin	:: !Bool	!(IOSt .l .p) -> ((Int,Int),		!IOSt .l .p)
getDefaultVMargin	:: !Bool	!(IOSt .l .p) -> ((Int,Int),		!IOSt .l .p)
getDefaultItemSpace	:: !Bool	!(IOSt .l .p) -> ((Int,Int),		!IOSt .l .p)
getWindowHMargin	:: !Id		!(IOSt .l .p) -> (!Maybe (Int,Int),	!IOSt .l .p)
getWindowVMargin	:: !Id		!(IOSt .l .p) -> (!Maybe (Int,Int),	!IOSt .l .p)
getWindowItemSpace	:: !Id		!(IOSt .l .p) -> (!Maybe (Int,Int),	!IOSt .l .p)
/*	getDefault((H/V)Margin)/ItemSpace) isWindow return the default values for the 
		horizontal and vertical window (if isWindow)/dialogue (if (not isWindow)) 
		margins and item spaces.
	getWindow((H/V)Margin/ItemSpace) return the current horizontal and vertical 
		margins and item spaces of the indicated window. These will have the default 
		values in case they were not specified as an attribute.
		In case the window does not exist, Nothing is yielded.
*/


enableWindow			:: !Id	!(IOSt .l .p) -> IOSt .l .p
disableWindow			:: !Id	!(IOSt .l .p) -> IOSt .l .p
enableWindowMouse		:: !Id	!(IOSt .l .p) -> IOSt .l .p
disableWindowMouse		:: !Id	!(IOSt .l .p) -> IOSt .l .p
enableWindowKeyboard	:: !Id	!(IOSt .l .p) -> IOSt .l .p
disableWindowKeyboard	:: !Id	!(IOSt .l .p) -> IOSt .l .p
/*	(en/dis)ableWindow
		(en/dis)ables the indicated window.
	(en/dis)ableWindowMouse
		(en/dis)ables mouse handling of the indicated window.
	(en/dis)ableWindowKeyboard
		(en/dis)ables keyboard handling of the indicated window.
	Disabling a window overrules the SelectStates of its elements, which all become 
	Unable. 
	Reenabling the window reestablishes the SelectStates of its elements.
	The functions have no effect in case of invalid Ids or Dialogs instances.
	The latter four functions also have no effect in case the Window does not have 
	the indicated attribute.
*/


getWindowSelectState		:: !Id	!(IOSt .l .p) ->(!Maybe SelectState,!IOSt .l .p)
getWindowMouseSelectState	:: !Id	!(IOSt .l .p) ->(!Maybe SelectState,!IOSt .l .p)
getWindowKeyboardSelectState:: !Id	!(IOSt .l .p) ->(!Maybe SelectState,!IOSt .l .p)
/*	getWindowSelectState
		yields the current SelectState of the indicated window.
	getWindow(Mouse/Keyboard)SelectState
		yields the current SelectState of the mouse/keyboard of the indicated 
		window.
	The functions return Nothing in case of invalid Ids or Dialogs instances or if 
	the Window does not have the indicated attribute.
*/


getWindowMouseStateFilter	:: !Id							!(IOSt .l .p)
							-> (!Maybe MouseStateFilter,	! IOSt .l .p)
getWindowKeyboardStateFilter:: !Id							!(IOSt .l .p)
							-> (!Maybe KeyboardStateFilter,	! IOSt .l .p)
setWindowMouseStateFilter	:: !Id !MouseStateFilter		!(IOSt .l .p)
														   -> IOSt .l .p
setWindowKeyboardStateFilter:: !Id !KeyboardStateFilter		!(IOSt .l .p)
														   -> IOSt .l .p
/*	getWindow(Mouse/Keyboard)StateFilter yields the current 
		(Mouse/Keyboard)StateFilter of the indicated window. Nothing is yielded in 
		case the window does not exist or has no Window(Mouse/Keyboard) attribute.
	setWindow(Mouse/Keyboard)StateFilter replaces the current 
		(Mouse/Keyboard)StateFilter of the indicated window. If the indicated window
		does not exist the function has no effect.
*/


appWindowPicture:: !Id !.(IdFun *Picture) !(IOSt .l .p) -> IOSt .l .p
accWindowPicture:: !Id !.(St *Picture .x) !(IOSt .l .p) -> (!Maybe .x,!IOSt .l .p)
/*	(app/acc)WindowPicture applies the given drawing function to the Picture of
	the indicated window (behind all controls). 
	Both functions have no effect in case the window is unknown or is a Dialog.
	In that case, accWindowPicture also returns Nothing.
*/


updateWindow	:: !Id !(Maybe ViewFrame)	!(IOSt .l .p) -> IOSt .l .p
/*	updateWindow applies the WindowLook attribute function of the indicated window.
	The SelectState argument of the Look attribute is the current SelectState of the
	window.
	The UpdateState argument of the Look attribute is 
		{oldFrame=frame,newFrame=frame,updArea=[frame]}
	where frame depends on the optional ViewFrame argument:
		in case of (Just rectangle):
			the intersection of the current ViewFrame of the window and rectangle.
		in case of Nothing:
			the current ViewFrame of the window. 
	updateWindow has no effect in case of unknown windows, or if the indicated 
	window is a Dialog, or the window has no WindowLook attribute, or the optional 
	viewframe argument is empty.
*/

setWindowLook	:: !Id !Bool !(!Bool,!Look)	!(IOSt .l .p) -> IOSt .l .p
getWindowLook	:: !Id						!(IOSt .l .p)
					  -> (!Maybe (Bool,Look),!IOSt .l .p)
/*	setWindowLook sets the (render/look) of the indicated window. 
		The window is redrawn only if the Boolean argument is True. 
		setWindowLook has no effect in case the window does not exist, or is a 
		Dialog.
	getWindowLook returns the (Just (render/look)) of the indicated window. 
		In case the window does not exist, or is a Dialog, or has no WindowLook 
		attribute, the result is Nothing. 
*/


setWindowPos	:: !Id !ItemPos	!(IOSt .l .p) -> IOSt .l .p
getWindowPos	:: !Id			!(IOSt .l .p) -> (!Maybe Vector2,!IOSt .l .p)
/*	setWindowPos places the window at the indicated position. 
		If the ItemPos argument refers to the Id of an unknown window (in case of 
		LeftOf/RightTo/Above/Below), setWindowPos has no effect. 
		If the ItemPos argument is one of (LeftOf/RightTo/Above/Below)Prev, then the
		previous window is the window that is before the window in the current 
		stacking order. 
		If the window is frontmost, setWindowPos has no effect. setWindowPos also 
		has no effect if the window would be moved outside the screen, or if the Id
		is unknown or refers to a modal Dialog.
	getWindowPos returns the current item offset position of the indicated window.
		The corresponding ItemPos is (LeftTop,OffsetVector offset). Nothing is 
		returned in case the window does not exist.
*/


moveWindowViewFrame	:: !Id Vector2 !(IOSt .l .p) -> IOSt .l .p
/*	moveWindowViewFrame moves the orientation of the view frame of the indicated 
	window over the given vector, and updates the window if necessary. The view 
	frame is not moved outside the ViewDomain of the window. 
	In case of unknown Id, or of Dialogs, moveWindowViewFrame has no effect.
*/

getWindowViewFrame	:: !Id !(IOSt .l .p) -> (!ViewFrame,!IOSt .l .p)
/*	getWindowViewFrame returns the current view frame of the window in terms of the
	ViewDomain. Note that in case of a Dialog, getWindowViewFrame returns 
	{zero,size}.
	In case of unknown windows, the ViewFrame result is zero.
*/

setWindowViewSize	:: !Id !Size	!(IOSt .l .p) -> IOSt .l .p
getWindowViewSize	:: !Id			!(IOSt .l .p) -> (!Size,!IOSt .l .p)
/*	setWindowViewSize
		sets the size of the view frame of the indicated window as given, and 
		updates the window if necessary. The size is fit between the minimum size 
		and the screen dimensions. 
		In case of unknown Ids, or of Dialogs, setWindowViewSize has no effect.
	getWindowViewSize yields the current size of the view frame of the indicated 
		window. If the window does not exist, zero is returned.
*/

setWindowOuterSize	:: !Id !Size	!(IOSt .l .p) -> IOSt .l .p
getWindowOuterSize	:: !Id			!(IOSt .l .p) -> (!Size,!IOSt .l .p)
/*	setWindowOuterSize
		sets the size of the outer frame of the indicated window as given, and 
		updates the window if necessary. The size is fit between the minimum size 
		and the screen dimensions. 
		In case of unknown Ids, or of Dialogs, setWindowOuterSize has no effect.
	getWindowOuterSize yields the current size of the outer frame of the indicated 
		window. If the window does not exist, zero is returned.
*/

setWindowViewDomain	:: !Id ViewDomain	!(IOSt .l .p) -> IOSt .l .p
getWindowViewDomain	:: !Id				!(IOSt .l .p)
				   -> (!Maybe ViewDomain,!IOSt .l .p)
/*	setWindowViewDomain
		sets the view domain of the indicated window as given. The window view frame
		is moved such that a maximum portion of the view domain is visible. The 
		window is not resized.
		In case of unknown Ids, or of Dialogs, setWindowViewDomain has no effect.
	getWindowViewDomain
		returns the current ViewDomain of the indicated window. 
		Nothing is returned in case the window does not exist or is a Dialog.
*/

setWindowScrollFunction :: !Id Direction ScrollFunction !(IOSt .l .p) -> IOSt .l .p
getWindowScrollFunction :: !Id Direction                !(IOSt .l .p)
							   -> (!Maybe ScrollFunction,!IOSt .l .p)
/*	setWindowScrollFunction 
		changes the current scroll function of the indicated Window and direction
		only if the indicated window already had a scroll bar in that direction. 
		In all other cases setWindowScrollFunction has no effect.
	getWindowScrollFunction
		returns the current scroll function in the argument direction if the 
		indicated Window had one. 
		In all other cases Nothing is returned. 
*/


setWindowTitle	:: !Id Title       !(IOSt .l .p) -> IOSt .l .p
setWindowOk		:: !Id Id          !(IOSt .l .p) -> IOSt .l .p
setWindowCancel	:: !Id Id          !(IOSt .l .p) -> IOSt .l .p
setWindowCursor	:: !Id CursorShape !(IOSt .l .p) -> IOSt .l .p
getWindowTitle	:: !Id             !(IOSt .l .p) -> (!Maybe Title,      !IOSt .l .p)
getWindowOk		:: !Id             !(IOSt .l .p) -> (!Maybe Id,         !IOSt .l .p)
getWindowCancel	:: !Id             !(IOSt .l .p) -> (!Maybe Id,         !IOSt .l .p)
getWindowCursor	:: !Id             !(IOSt .l .p) -> (!Maybe CursorShape,!IOSt .l .p)
/*	setWindow(Title/Ok/Cancel/Cursor) set the indicated window attributes.
		In case of unknown Ids, these functions have no effect.
	getWindow(Title/Ok/Cancel/Cursor) get the indicated window attributes.
		In case of unknown Ids, the result is Nothing.
*/
